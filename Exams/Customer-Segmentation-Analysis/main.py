# -*- coding: utf-8 -*-
"""Customer Segmentation Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bz0D-MfyVZVmT_Qy2jAaHK6-zwbCIHzg
"""

import pandas as pd
from sklearn.preprocessing import MinMaxScaler

# Commented out IPython magic to ensure Python compatibility.
# %pip install fuzzy-c-means

"""### Preprocessing"""

# Connect drive
from google.colab import drive
drive.mount('/content/drive')

df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/Datasets/online_retail.csv', encoding='ISO-8859-1')

# Filter only valid transactions
df = df[df['Quantity'] > 0]
df = df[df['Price'] > 0]


# Compute total transaction amount
df['TotalAmount'] = df['Quantity'] * df['Price']

# Convert InvoiceDate to datetime
df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'])
df

"""### Calculating RFM"""

# Reference date (choose one day after the last invoice)
snapshot_date = df['InvoiceDate'].max() + pd.Timedelta(days=1)

# Group by customer
rfm = df.groupby('Customer ID').agg({
    'InvoiceDate': lambda x: (snapshot_date - x.max()).days,  # Recency
    'Invoice': 'nunique',                                      # Frequency
    'TotalAmount': 'sum'                                       # Monetary
}).rename(columns={
    'InvoiceDate': 'Recency',
    'Invoice': 'Frequency',
    'TotalAmount': 'Monetary'
}).reset_index()

# Optional: round Monetary values
rfm['Monetary'] = rfm['Monetary'].round(2)

# Preview
print(rfm.head())

# Normalize the RFM values
scaler = MinMaxScaler()
rfm_scaled = pd.DataFrame(
    scaler.fit_transform(rfm[['Recency', 'Frequency', 'Monetary']]),
    columns=['Recency', 'Frequency', 'Monetary']
)
print(rfm_scaled.head())

"""### Create Product-Level Features per Customer"""

# Pivot table: Rows = Customer ID, Columns = StockCode, Values = total quantity
product_matrix = df.pivot_table(
    index='Customer ID',
    columns='StockCode',
    values='Quantity',
    aggfunc='sum',
    fill_value=0
)

# Convert to binary (whether a product was purchased or not)
product_matrix_binary = (product_matrix > 0).astype(int)

# Ensure same order of customers as in RFM
product_matrix_binary = product_matrix_binary.loc[rfm['Customer ID']]

# Combine RFM and product-level features
import numpy as np

rfm_features = rfm_scaled.values  # shape: (n_customers, 3)
product_features = product_matrix_binary.values  # shape: (n_customers, N)

combined_features = np.hstack([rfm_features, product_features])

"""### ABC Feature Selection"""

import sys
sys.path.append('/content/drive/MyDrive/Colab Notebooks/custom_modules')

from abc_feature_selection import ABCFeatureSelector

sample_idx = np.random.choice(combined_features.shape[0], size=5000, replace=False)
sample_data = combined_features[sample_idx]

selector = ABCFeatureSelector(
    data=sample_data,
    num_bees=30,
    max_iter=20,
    k_range=(2, 4)
)
selected_features, best_k, score = selector.optimize()

# Apply feature mask
selected_data = combined_features[:, selected_features == 1]

"""### Run All Clustering Methods"""

from clustering_algorithms import kmeans_clustering, ward_clustering, fuzzy_cmeans_clustering

# Run clustering algorithms
kmeans_labels = kmeans_clustering(selected_data, best_k)
ward_labels = ward_clustering(selected_data, best_k)
fcm_labels, fuzzy_memberships = fuzzy_cmeans_clustering(selected_data, best_k)

"""### Combine Labels Using Majority Voting"""

# Combine Labels Using Majority Voting

from scipy.stats import mode
import numpy as np

all_labels = np.vstack([kmeans_labels, ward_labels, fcm_labels])

# Calculate the mode along axis 0 (across the different clustering results)
# The result of mode() has a 'mode' attribute which is an array of the mode values.
# We need to extract this array and ensure it's 1D.
# Accessing the .mode attribute directly gives the array of modes.
# Ensure it's an integer type for labels.
final_labels = mode(all_labels, axis=0).mode.flatten().astype(int)


# shape: (n_customers,)
# final_labels = final_labels.flatten().astype(int) # Original line, potentially causing issues

print("Labels:", np.unique(final_labels))
print("Data type:", final_labels.dtype)
print("Shape of final_labels:", final_labels.shape) # Added for verification

"""### Train the Improved Fuzzy Decision Tree"""

from fuzzy_decision_tree import FuzzyDecisionTreeNode

tree = FuzzyDecisionTreeNode(max_depth=3)
tree.fit(selected_data, final_labels, fuzzy_memberships)

"""### Predict and Evaluate Accuracy"""

predicted_labels = tree.predict(selected_data)

from sklearn.metrics import accuracy_score
accuracy = accuracy_score(final_labels, predicted_labels)
print("Fuzzy Decision Tree Accuracy:", round(accuracy * 100, 2), "%")
